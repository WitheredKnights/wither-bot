
//# How do I ban a user?
const user = interaction.options.getUser('target');
guild.members.ban(user);


//# How do I unban a user?
const user = interaction.options.getUser('target');
guild.members.unban(user);


//# How do I kick a guild member?
const member = interaction.options.getMember('target');
member.kick();


//# How do I timeout a guild member?
const member = interaction.options.getMember('target');
member.timeout(60_000); // Timeout for one minute


//# How do I add a role to a guild member?
const role = interaction.options.getRole('role');
const member = interaction.options.getMember('target');
member.roles.add(role);


//# How do I check if a guild member has a specific role?
const member = interaction.options.getMember('target');
if (member.roles.cache.some(role => role.name === 'role name')) {
	// ...
}


//# How do I limit a command to a single user?
if (interaction.user.id === 'id') {
	// ...
}


//# How do I set my bot's username?
client.user.setUsername('username');


//# How do I set my bot's avatar?
client.user.setAvatar('URL or path');


//# How do I set my playing status?
client.user.setActivity('activity');


//# How do I set my status to "Watching/Listening to/Competing in ..."?
const { ActivityType } = require('discord.js');

client.user.setActivity('activity', { type: ActivityType.Watching });
client.user.setActivity('activity', { type: ActivityType.Listening });
client.user.setActivity('activity', { type: ActivityType.Competing });


//# How do I make my bot display online/idle/dnd/invisible?
client.user.setStatus('online');
client.user.setStatus('idle');
client.user.setStatus('dnd');
client.user.setStatus('invisible');


//# How do I set both status and activity in one go?
client.user.setPresence({ activities: [{ name: 'activity' }], status: 'idle' });


//# How do I send a message to a specific channel?
const channel = client.channels.cache.get('id');
channel.send('content');


//TIPCurrently, the only way to get tag ids is programmatically through ForumChannel#availableTagsopen in new window.
const channel = client.channels.cache.get('id');
channel.threads.create({ name: 'Post name', message: { content: 'Message content' }, appliedTags: ['tagID', 'anotherTagID'] });


//# How do I DM a specific user?
client.users.send('id', 'content');


//# How do I mention a specific user in a message?
const user = interaction.options.getUser('target');
await interaction.reply(`Hi, ${user}.`);
await interaction.followUp(`Hi, <@${user.id}>.`);


//This can be set as a default in ClientOptions, and controlled per-message sent by your bot.
new Client({ allowedMentions: { parse: ['users', 'roles'] } });


//Even more control can be achieved by listing specific users or roles to be mentioned by ID, e.g.:
channel.send({
	content: '<@123456789012345678> <@987654321098765432> <@&102938475665748392>',
	allowedMentions: { users: ['123456789012345678'], roles: ['102938475665748392'] },
});


//# How do I prompt the user for additional input?
interaction.reply('Please enter more input.').then(() => {
	const filter = m => interaction.user.id === m.author.id;

	interaction.channel.awaitMessages({ filter, time: 60000, max: 1, errors: ['time'] })
		.then(messages => {
			interaction.followUp(`You've entered: ${messages.first().content}`);
		})
		.catch(() => {
			interaction.followUp('You did not enter any input!');
		});
});


//# How do I block a user from using my bot?
const blockedUsers = ['id1', 'id2'];
client.on(Events.InteractionCreate, interaction => {
	if (blockedUsers.includes(interaction.user.id)) return;
});


//You do not need to have a constant local variable like blockedUsers above. If you have a database system that you use to store IDs of blocked users, you can query the database instead:
client.on(Events.InteractionCreate, async interaction => {
	const blockedUsers = await database.query('SELECT user_id FROM blocked_users;');
	if (blockedUsers.includes(interaction.user.id)) return;
});


//# How do I react to the message my bot sent?
interaction.channel.send('My message to react to.').then(sentMessage => {
	// Unicode emoji
	sentMessage.react('👍');

	// Custom emoji
	sentMessage.react('123456789012345678');
	sentMessage.react('<emoji:123456789012345678>');
	sentMessage.react('<a:emoji:123456789012345678>');
	sentMessage.react('emoji:123456789012345678');
	sentMessage.react('a:emoji:123456789012345678');
});


//# How do I restart my bot with a command?
process.exit();


//# How do I find all online members of a guild?
// First use guild.members.fetch to make sure all members are cached
guild.members.fetch({ withPresences: true }).then(fetchedMembers => {
	const totalOnline = fetchedMembers.filter(member => member.presence?.status === 'online');
	// Now you have a collection with all online member objects in the totalOnline variable
	console.log(`There are currently ${totalOnline.size} members online in this guild!`);
});


//# How do I check which role was added/removed and for which member?
// Start by declaring a guildMemberUpdate listener
// This code should be placed outside of any other listener callbacks to prevent listener nesting
client.on(Events.GuildMemberUpdate, (oldMember, newMember) => {
	// If the role(s) are present on the old member object but no longer on the new one (i.e role(s) were removed)
	const removedRoles = oldMember.roles.cache.filter(role => !newMember.roles.cache.has(role.id));
	if (removedRoles.size > 0) {
		console.log(`The roles ${removedRoles.map(r => r.name)} were removed from ${oldMember.displayName}.`);
	}

	// If the role(s) are present on the new member object but are not on the old one (i.e role(s) were added)
	const addedRoles = newMember.roles.cache.filter(role => !oldMember.roles.cache.has(role.id));
	if (addedRoles.size > 0) {
		console.log(`The roles ${addedRoles.map(r => r.name)} were added to ${oldMember.displayName}.`);
	}
});


//There are two common measurements for bot pings. The first, websocket heartbeat, is the average interval of a regularly sent signal indicating the healthy operation of the websocket connection the library receives events over:
interaction.reply(`Websocket heartbeat: ${client.ws.ping}ms.`);


//The second, Roundtrip Latency, describes the amount of time a full API roundtrip (from the creation of the command message to the creation of the response message) takes. You then edit the response to the respective value to avoid needing to send yet another message:
const sent = await interaction.reply({ content: 'Pinging...', fetchReply: true });
interaction.editReply(`Roundtrip latency: ${sent.createdTimestamp - interaction.createdTimestamp}ms`);


//If you've tried using the usual method of retrieving unicode emojis, you may have noticed that some characters don't provide the expected results. Here's a short snippet that'll help with that issue. You can toss this into a file of its own and use it anywhere you need! Alternatively feel free to simply copy-paste the characters from below:
// emojiCharacters.js
module.exports = {
	a: '🇦', b: '🇧', c: '🇨', d: '🇩',
	e: '🇪', f: '🇫', g: '🇬', h: '🇭',
	i: '🇮', j: '🇯', k: '🇰', l: '🇱',
	m: '🇲', n: '🇳', o: '🇴', p: '🇵',
	q: '🇶', r: '🇷', s: '🇸', t: '🇹',
	u: '🇺', v: '🇻', w: '🇼', x: '🇽',
	y: '🇾', z: '🇿', 0: '0️⃣', 1: '1️⃣',
	2: '2️⃣', 3: '3️⃣', 4: '4️⃣', 5: '5️⃣',
	6: '6️⃣', 7: '7️⃣', 8: '8️⃣', 9: '9️⃣',
	10: '🔟', '#': '#️⃣', '*': '*️⃣',
	'!': '❗', '?': '❓',
};


//// emojiCharacters.js
//module.exports = {
//	a: '🇦', b: '🇧', c: '🇨', d: '🇩',
//	e: '🇪', f: '🇫', g: '🇬', h: '🇭',
//	i: '🇮', j: '🇯', k: '🇰', l: '🇱',
//	m: '🇲', n: '🇳', o: '🇴', p: '🇵',
//	q: '🇶', r: '🇷', s: '🇸', t: '🇹',
//	u: '🇺', v: '🇻', w: '🇼', x: '🇽',
//	y: '🇾', z: '🇿', 0: '0️⃣', 1: '1️⃣',
//	2: '2️⃣', 3: '3️⃣', 4: '4️⃣', 5: '5️⃣',
//	6: '6️⃣', 7: '7️⃣', 8: '8️⃣', 9: '9️⃣',
//	10: '🔟', '#': '#️⃣', '*': '*️⃣',
//	'!': '❗', '?': '❓',
//};
//1234567891011121314
// index.js
const emojiCharacters = require('./emojiCharacters.js');

console.log(emojiCharacters.a); // 🇦
console.log(emojiCharacters[10]); // 🔟
console.log(emojiCharacters['!']); // ❗


